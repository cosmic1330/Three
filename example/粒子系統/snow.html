<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Box</title>
    <style>
        body { margin: 0; }
    </style>
	<script src='https://cdnjs.cloudflare.com/ajax/libs/three.js/r99/three.min.js' integrity='sha512-0tlhMhMGPohLm/YwaskxH7jJuUGqU/XPTl+HE0dWrhGbpEBRIZYMQdbHC0CmyNPzZKTBd8JoVZnvMcL7hzlFOg==' crossorigin='anonymous'></script>
</head>
<body>
    <div id="stats"></div>
    <script type="module">
        import { OrbitControls } from "https://threejs.org/examples/jsm/controls/OrbitControls.js";

        let renderer, scene, camera
        let cameraControl, stats

        // points
        const particleCount = 15000
        let points

        // 建立粒子系統
        function createPoints() {
            const geometry = new THREE.Geometry()

            

            const texture = new THREE.TextureLoader().load('./snowflake.png')
            let material = new THREE.PointsMaterial({
                size: 5,
                map: texture,
                blending: THREE.AdditiveBlending,
                depthTest: false,
                transparent: true,
                opacity: 0.7
            })

            const range = 250
            for (let i = 0; i < particleCount; i++) {
                const x = THREE.Math.randInt(-range, range)
                const y = THREE.Math.randInt(-range, range)
                const z = THREE.Math.randInt(-range, range)
                const point = new THREE.Vector3(x, y, z)
                point.velocityX = THREE.Math.randFloat(-0.16, 0.16) // 粒子橫向移動速度
                point.velocityY = THREE.Math.randFloat(0.1, 0.3) // 粒子縱向移動速度
                geometry.vertices.push(point)
            }

            points = new THREE.Points(geometry, material)
            scene.add(points)
        }

        // 雪花落下循環動畫
        function pointsAnimation() {
            points.geometry.vertices.forEach(function(v) {
                v.y = v.y - v.velocityY
                v.x = v.x - v.velocityX

                if (v.y <= -250) v.y = 250
                if (v.x <= -250 || v.x >= 250) v.velocityX = v.velocityX * -1
            })

            points.geometry.verticesNeedUpdate = true // 告訴渲染器需更新頂點位置
        }

        function init() {
            // scene
            scene = new THREE.Scene()
            scene.fog = new THREE.FogExp2(0x000000, 0.0008)

            // camera
            camera = new THREE.PerspectiveCamera(
                70,
                window.innerWidth / window.innerHeight,
                1,
                1000
            )
            camera.position.set(0, 0, 100)
            camera.lookAt(scene.position)

            // renderer
            renderer = new THREE.WebGLRenderer()
            renderer.setSize(window.innerWidth, window.innerHeight)

            // OrbitControls
            cameraControl = new OrbitControls(camera, renderer.domElement)
            cameraControl.enableDamping = true
            cameraControl.dampingFactor = 0.25

            createPoints()

            document.body.appendChild(renderer.domElement)
        }

        function render() {
            requestAnimationFrame(render)
            pointsAnimation()
            cameraControl.update()
            renderer.render(scene, camera)
        }

        window.addEventListener('resize', function() {
            camera.aspect = window.innerWidth / window.innerHeight
            camera.updateProjectionMatrix()
            renderer.setSize(window.innerWidth, window.innerHeight)
        })

        init()
        render()
    </script>
</body>
</html>